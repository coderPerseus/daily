# 事件循环

懂前端的都知道这里的门道有多深，我们今天看一下事件循环的前世今生

## 事件循环的来源

游览器的进程模型（事件循环发生的位置）

什么是进程？

简单理解为：为「程序运行」分配的「内存空间」。

进程的特点：

- 每个程序（应用）至少有一个进程
- 进程可以有多个，进程之前相互独立，如果需要通信需要双方同意
- 每个进程是隔离的，一个进程崩溃了，不会影响其他的进程

什么是线程？

运行程序代码的「人」就是「线程」

一个进程至少会有一个线程（主线程，也就是跟随进程启动的时候产生的线程），这里是因为内存空间是宝贵的，如果没有线程，内存空间就会被释放

一个进程可以有多个线程， 例如：微信进程，就会有很多线程，如发送消息线程、接受消息线程、看朋友圈线程等等

游览器中的进程和线程

游览器是一个多进程和多线程的程序

多线程好理解，多进程可以想一下我们的 chrome 游览器一个页面卡死了，但是其他页面不受影响，那么就可以说一个页面就是一个进程，不会影响其他页面（进程）

游览器中的三个进程

1）游览器进程：它负责 chrome 游览器的界面（是全局的界面）显示，用户交互，子进程管理（最开始游览器启动只有这一个进程，但是它会启动其他进程）

2）网络进程：加载网络资源

3）渲染进程：开启一个渲染主线程，主线程负责执行 HTML、CSS、JS

默认情况：游览器会为每一个标签页开启一个新的渲染进程，保证不同标签页面互不影响

事件循环发生在渲染主线程

## 渲染主线程如何工作？

它要做什么？下面这些都是渲染主线程的工作

- 解析 HTML
- 解析 CSS
- 计算样式
- 布局
- 处理图像
- 每秒把页面画 60 次
- 执行全局 JS 代码
- 执行事件处理函数
- 执行计时器的回调函数
- 。。。。

为什么渲染进程不适用多个线程来处理这些事情？而是全部交给渲染主线程？

主要原因：

1. JavaScript 是单线程，如果开启多个线程，需要处理复杂的线程同步；
2. 还可能出现多个线程同时操作 DOM 导致的竞态条件
3. 一致性问题，如：dom 操作循序性和原子性、JavaScript 代码执行顺序

### 如何调度任务？

排队

通过其他线程来执行一些程序，生成任务，然后任务会进入消息队列（message queue），然后渲染主线程会把消息队列中的任务依次进行执行

最开始，渲染主线程进入无线循环

每次循环都会查看是否有任务，有任务会执行任务，没有任务进入休眠

其他线程可以随时向消息队列添加任务（加入到队列末尾），如果新任务加入时渲染主线程在休眠，就会被唤醒

### 什么是异步 ？什么是同步？

同步就是按照代码程序的顺序依次执行，上一个执行完成再执行下一个

哪些是异步？

- 定时器
- 通信（网络）
- 事件监听

但是渲染主线程就一个，它无法接受异步，如果有异步的操作，那就会产生「阻塞」，从而导致游览器卡死，

那如何解决这个问题呢？

面试题：如何理解 JS 的异步？

JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他往务先法得到执行。“这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。

所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的未尾排队，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

### 任务有优先级吗？

不好意思，任务没有优先级

但是，消息队列有优先级

w3c：每一个任务都有一个任务类型，同一种任务类型的任务都在一个队列，不同任务类型可以分属于不同的队列（潜台词：不同的任务类型，可以在同一个队列）在一次事件循环，游览器可以根据实际情况从不同队列取出任务执行

游览器必须有一个微队列（microtask queue）微队列任务优先于所有其他任务队列

立即把一个函数添加到微队列的方法：`Promise.resolve().then(fn)`

面试题：阐述一下 JS 的事件循环

参考答案：

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。

过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。

面试题：JS 中的计时器能做到精确计时吗？为什么？

参考答案：

不行，因为：

1.  计算机硬件没有原子钟，无法做到精确计时
2.  操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3.  按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
4.  受事件循环影响，计时器的回调函数只能在主线程空闲时运行，又会带来偏差
